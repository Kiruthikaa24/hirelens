# -*- coding: utf-8 -*-
"""Copy of Hirelens.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17JyQi3RvJa2zlcVo8u0IqaCJb4fhxhyv
"""

!pip install pdfplumber sentence-transformers PyPDF2 pdfminer.six

# üì¶ Install Required Packages
!pip install pdfminer.six sentence-transformers

# üì§ Upload Resumes
from google.colab import files
uploaded_files = files.upload()

# üìÇ Save Uploaded Files
import os
resume_folder = "uploaded_resumes"
os.makedirs(resume_folder, exist_ok=True)
for filename in uploaded_files:
    with open(os.path.join(resume_folder, filename), "wb") as f:
        f.write(uploaded_files[filename])

# üìö Imports
import re
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from sentence_transformers import SentenceTransformer
from sklearn.metrics.pairwise import cosine_similarity
from pdfminer.high_level import extract_text

# ‚úâÔ∏è Email Configuration (use Gmail App Password)
EMAIL_SENDER = "ak2kiruthika@gmail.com"
EMAIL_PASSWORD = "rcxa hcve hwyx ewrw"  # Use App Password
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587

# üß† Load Sentence-BERT Model
model = SentenceTransformer('all-MiniLM-L6-v2')

# üìù Job Descriptions
job_descriptions = {
    "Web Developer": {
        "skills": "HTML, CSS, JavaScript, React, Responsive Design, Git",
        "experience": "1+ years of web development experience. Ability to build user-friendly websites."
    },
    "Software Engineer": {
        "skills": "Python, Java, Data Structures, Algorithms, Problem Solving, Git",
        "experience": "2+ years of software engineering experience. Strong understanding of system design and coding."
    }
}

# üì§ Extract Email and Text from PDF
def extract_email_pdfminer(pdf_path):
    text = extract_text(pdf_path).replace('\n', ' ')
    emails = re.findall(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', text)
    return emails[0] if emails else "Not found", emails, text

# üß† Match Resume with Job using BERT
def match_resume_with_bert(job_desc, resume_text):
    job_embedding = model.encode(job_desc, convert_to_tensor=True)
    resume_embedding = model.encode(resume_text, convert_to_tensor=True)
    return cosine_similarity([job_embedding], [resume_embedding])[0][0]

# üìß Send Email
def send_email(recipient, score, is_selected, reason):
    subject = "Interview Invitation" if is_selected else "Application Update"
    body = f"""Dear Applicant,

Your resume score: {score:.2f}

{"‚úÖ We are pleased to invite you to the next round." if is_selected else "‚ùå We're unable to proceed with your application."}

üìå Reason: {reason}

Regards,
HR Team
"""
    message = MIMEMultipart()
    message["From"] = EMAIL_SENDER
    message["To"] = recipient
    message["Subject"] = subject
    message.attach(MIMEText(body, "plain"))

    try:
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls()
            server.login(EMAIL_SENDER, EMAIL_PASSWORD)
            server.send_message(message)
        print(f"‚úÖ Email sent to {recipient}")
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to send email to {recipient}: {e}")

# üîç Process Resumes with Normalization
def process_resumes(resume_folder, selected_job_role, threshold=0.8):
    jd = job_descriptions[selected_job_role]
    job_text = jd["skills"] + ". " + jd["experience"]

    print("üì• Scanning and calculating raw scores...")
    raw_scores = []
    file_data = []

    for filename in os.listdir(resume_folder):
        if filename.endswith(".pdf"):
            filepath = os.path.join(resume_folder, filename)
            email, _, text = extract_email_pdfminer(filepath)
            raw_score = match_resume_with_bert(job_text, text)
            file_data.append((filename, email, text, raw_score))

    if not file_data:
        print("‚ö†Ô∏è No PDF resumes found.")
        return

    min_score = min([fd[3] for fd in file_data])
    max_score = max([fd[3] for fd in file_data])

    def normalize(score):
        return (score - min_score) / (max_score - min_score) if max_score != min_score else 1.0

    selected = []
    rejected = []

    print("\nüß† Evaluating resumes...")
    for filename, email, text, raw_score in file_data:
        normalized_score = normalize(raw_score)

        if 'React' not in text and selected_job_role == "Web Developer":
            reason = "Missing required skill: React"
        elif '2 years' not in text and selected_job_role == "Software Engineer":
            reason = "Lack of required experience"
        elif normalized_score < threshold:
            reason = "Low match score"
        else:
            reason = "Strong match"

        if normalized_score >= threshold:
            selected.append((filename, normalized_score, email, reason))
        else:
            rejected.append((filename, normalized_score, email, reason))

    # ‚úÖ Selected
    print("\n‚úÖ Selected Resumes:")
    for file, score, email, reason in selected:
        print(f"{file} - Score: {score:.2f} - Email: {email} - Reason: {reason}")

    # ‚ùå Rejected
    print("\n‚ùå Rejected Resumes:")
    for file, score, email, reason in rejected:
        print(f"{file} - Score: {score:.2f} - Email: {email} - Reason: {reason}")

    # üì© Send Emails
    print("\nüì© Sending Emails...")
    for group, is_selected in [(selected, True), (rejected, False)]:
        for _, score, email, reason in group:
            if email != "Not found":
                send_email(email, score, is_selected, reason)
            else:
                print("Email not found in resume.")

# ‚ñ∂Ô∏è Run the Processor
process_resumes(resume_folder, selected_job_role="Web Developer", threshold=0.8)

!pip install flask pyngrok

# Install dependencies
!pip install flask pyngrok --quiet

# Set your ngrok auth token (REPLACE with your actual token from https://dashboard.ngrok.com/get-started/setup)
!ngrok authtoken 2vARD4DreEgK1WF2rvkWCL7C1TT_2quKk6ridSdaBcHBCvHqf

!pip install flask flask-cors pyngrok

from flask import Flask, request, jsonify
from flask_cors import CORS
from werkzeug.utils import secure_filename
from pyngrok import ngrok
import os

app = Flask(__name__)
CORS(app)

UPLOAD_FOLDER = "uploaded_resumes"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Max upload size (16 MB)

# Allowed file extensions for resumes
ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx'}

def allowed_file(filename):
    """Check if the file has a valid extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def process_resumes(folder, selected_job_role, top_n):
    # Your logic for processing resumes (e.g., filtering or analyzing them)
    print(f"Processing resumes for {selected_job_role} and fetching top {top_n} matches.")
    # You can add your actual resume processing logic here.

@app.route("/filter", methods=["POST"])
def filter_resumes_api():
    if 'role' not in request.form or 'resumes' not in request.files:
        return jsonify({"error": "Missing role or files"}), 400

    role = request.form.get("role")
    files = request.files.getlist("resumes")

    # Validate that files have a valid extension
    for file in files:
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        else:
            return jsonify({"error": "Invalid file format. Only pdf, doc, and docx are allowed."}), 400

    # Process resumes (this should be your logic to analyze the resumes)
    process_resumes(UPLOAD_FOLDER, selected_job_role=role, top_n=2)

    return jsonify({"message": f"Filtering complete for {role}"}), 200

# üîó Expose via ngrok
public_url = ngrok.connect(5000)
print(f"üì° Public URL: {public_url}")

# Running the app without reloader since ngrok sometimes doesn't work well with it.
app.run(port=5000, debug=False, use_reloader=False)